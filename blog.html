<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Blog For Q&A</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-iYQeCzEYFbKjA/T2uDLTpkwGzCiq6soy8tYaI1GyVh/UjpbCx/TYkiZhlZB6+fzT" crossorigin="anonymous">
</head>

<body>
    <h1 class="container text-center mt-4">Most asked Qustions & their answers!!!</h1>
    <section>
        <div>
            <div class="accordion accordion-flush w-50 container" id="accordionFlushExample">
                <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingOne">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#flush-collapseOne" aria-expanded="false" aria-controls="flush-collapseOne">
                            What are the differences between Local Storage & Session Storage?
                        </button>
                    </h2>
                    <div id="flush-collapseOne" class="accordion-collapse collapse" aria-labelledby="flush-headingOne"
                        data-bs-parent="#accordionFlushExample">
                        <div class="accordion-body">
                            <p><b>Local Storage:</b> Local Storage is a type of web storage that allows JavaScript to
                                store and access data right in the browser.<br>
                                <b>Session Storage:</b> Session Storage is a type of web storage that allows web
                                applications to store data locally within the user's browser. Unlike cookies, data
                                stored in session storage is specific to the site on which it was created and data is
                                not shared with other sites. <br> <br>
                                <b>Local Storage:</b> The storage capacity of local storage is 5MB/10MB. <br>
                                <b>Session Storage:</b> The storage capacity of session storage is 5MB. <br>
                                <br>
                                <b>Local Storage:</b> As it is not session-based, it must be deleted via javascript or
                                manually. <br>
                                <b>Session Storage:</b> It’s session-based and works per window or tab. This means that
                                data is stored only for the duration of a session, i.e., until the browser (or tab) is
                                closed.
                                <br>
                                <br>
                                <b>Local Storage:</b>The stored data is not deleted when the browser is closed. <br>
                                <b>Session Storage:</b> The data is stored only for the session and will be deleted when
                                the
                                browser is closed. <br>
                                <br>
                                <b>Local Storage:</b> Local storage is useful for storing data that the user will need
                                to
                                access later, such as offline data. <br>

                                <b>Session Storage:</b> Session storage is a great way to improve the performance of
                                the web
                                applications. <br>
                                <br>
                                <b>Local Storage:</b> This is especially useful for storing data that the user want to
                                persist
                                even if the user closes the browser, such as preferences or settings. <br>
                                <b>Session Storage:</b> Session storage is useful for storing data that is sensitive,
                                such as
                                login credentials.
                            </p>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingTwo">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#flush-collapseTwo" aria-expanded="false" aria-controls="flush-collapseTwo">
                            What are the differences between Global Scope and Block Scope?
                        </button>
                    </h2>
                    <div id="flush-collapseTwo" class="accordion-collapse collapse" aria-labelledby="flush-headingTwo"
                        data-bs-parent="#accordionFlushExample">
                        <div class="accordion-body">
                            <p><b>Global Scope:</b></p>
                            <p> 1. Any variable declared outside of a function is said to have
                                Global Scope. <br>
                                2. In simple terms, a variable that can be accessed anywhere in the program is known as
                                a variable with global scope. Globally scoped variables can be defined using any of the
                                three keywords: let, const, and var. <br>
                                3. A global variable can be accessed by any function. That is why a global variable is
                                available for use throughout the entire program after its declaration. <br>
                                4. If the global variable is not initialized, then zero is stored as default. <br>
                                5. The global variable stored on a fixed location decided by the compiler. <br>
                                6. Data sharing is possible as multiple functions can access the same global variable.
                                <br>
                                <br>
                            </p>
                            <p><b>Block Scope:</b></p>
                            <p> 1. Before introducing ES6 (ECMAScript 6) in 2015, JavaScript had only two types of
                                scopes: Global Scope and Local Scope. <br>
                                2. With the introduction of let and const keywords, it added a new type of Scope in
                                JavaScript. One cannot access the variables declared inside a particular block
                                (represented by {}) from outside the block. <br>
                                3. The block scope does not work with the var keyword. The programmers can either use
                                let or const
                                keywords for that. <br>
                                4. A block scope is the area within if, switch conditions or for and while loops.
                                Generally speaking, whenever the programmers see {curly brackets}, it is a block. In
                                ES6,
                                const and let keywords allow developers to declare variables in the block scope, which
                                means those variables exist only within the corresponding block. <br>
                                5. Block scope is also a sub-type of local scope. The block scope can be defined as the
                                scope of the variables inside the curly brackets {}. Now, these curly brackets can be of
                                loops, or conditional statements, or something else. The programmers are only allowed to
                                refer to these variables from within the curly brackets {}.
                                <br>
                                <br>
                            </p>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingThree">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#flush-collapseThree" aria-expanded="false"
                            aria-controls="flush-collapseThree">
                            How event loop works in javascript?
                        </button>
                    </h2>
                    <div id="flush-collapseThree" class="accordion-collapse collapse"
                        aria-labelledby="flush-headingThree" data-bs-parent="#accordionFlushExample">
                        <div class="accordion-body">
                            <p>JavaScript is a single-threaded synchronous programming language. It means that the main
                                thread where JavaScript code is run, runs in one line at a time manner and there is no
                                possibility of running code in parallel. Inside Browser, there is a Javascript engine
                                (we are considering V8 for chrome.) and an environment to run javascript properly.
                                Javascript engine has two parts, Heap and Call Stack. And the engine has some assistant
                                named Web APIs and Callback Queue.<br>
                                <b>V8 Engine:</b>
                                The V8 engine is a high performance, Open-source web assembly runtime engine for
                                JavaScript written in C++ by Google. Most browsers run JavaScript using the V8 engine,
                                and even the popular node js runtime environment uses it too.

                                In simple English, the V8 is a C++ program, which receives JavaScript code, compiles,
                                and executes it.

                                The V8 does two major things;

                                Heap memory allocation
                                Call stack execution context
                                Sadly, our suspicion was wrong. The V8 has just one call stack, think of the call stack
                                as the thread.

                                One thread === one call stack === one execution at a time.
                                <br>
                                <b>Heaps:</b>
                                It's an unstructured memory block. Our code's memory allocation happens here. As a
                                programmer we don't have to worry much about heaps. <br>
                                <b>Stack memory: </b> Memory allocated in the form of stacks. Mainly used for functions.
                                <br>
                                <b>Call Stack:</b>
                                We can consider Call Stack as a kitchen where all our code executed or cooked. Whenever
                                we try to run a piece of code, it goes to call stack first and then executed. It works
                                in LIFO style. That is Last In First Out. <br>
                                <b>Web APIs:</b>
                                Web API works as JS engines assistant. When JS engine have to deal with asynchronous
                                code, it takes the help of Web API. Web API handles the blocking behavior of JavaScript
                                code. <br>
                                <b>Callback Queue:</b>
                                It's a guard who monitors the stack of asynchronous callback functions who just
                                completed the task of waiting and passed the gate of Web API. Callback Queue works using
                                FIFO (First In First Out ) method. And now, they waits here to go back to Call Stack.
                                <br>
                                <b>Event Loop:</b>
                                Event loop is just a guardian who keeps a good communication with Call Stack and
                                Callback Queue. It checks if the call stack is free, then lets know the callback queue.
                                Then Callback queue passes the callback function to Call stack to be executed. When all
                                the callback functions are executed, the call stack is out and global execution context
                                is free. <br>
                                <b>Run-to-completion: </b>
                                Each message is processed completely before any other message is processed.

                                This offers some nice properties when reasoning about your program, including the fact
                                that whenever a function runs, it cannot be preempted and will run entirely before any
                                other code runs (and can modify data the function manipulates). This differs from C, for
                                instance, where if a function runs in a thread, it may be stopped at any point by the
                                runtime system to run some other code in another thread.

                                A downside of this model is that if a message takes too long to complete, the web
                                application is unable to process user interactions like click or scroll. The browser
                                mitigates this with the "a script is taking too long to run" dialog. A good practice to
                                follow is to make message processing short and if possible cut down one message into
                                several messages.
                                <br>
                                <b>Adding messages:</b>
                                In web browsers, messages are added anytime an event occurs and there is an event
                                listener attached to it. If there is no listener, the event is lost. So a click on an
                                element with a click event handler will add a message — likewise with any other event.
                                <br>
                                <b>Zero delays:</b>
                                Zero delay doesn't mean the call back will fire-off after zero milliseconds. Calling
                                setTimeout with a delay of 0 (zero) milliseconds doesn't execute the callback function
                                after the given interval. <br>
                                <b>Several runtimes communicating together: </b>
                                A web worker or a cross-origin iframe has its own stack, heap, and message queue. Two
                                distinct runtimes can only communicate through sending messages via the postMessage
                                method. This method adds a message to the other runtime if the latter listens to message
                                events. <br>

                                <b>Never blocking: </b>
                                A very interesting property of the event loop model is that JavaScript, unlike a lot of
                                other languages, never blocks. Handling I/O is typically performed via events and
                                callbacks, so when the application is waiting for an IndexedDB query to return or an XHR
                                request to return, it can still process other things like user input.
                            </p>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingFour">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#flush-collapseFour" aria-expanded="false"
                            aria-controls="flush-collapseFour">
                            In how many ways we get "undefined" using JavaScript?
                        </button>
                    </h2>
                    <div id="flush-collapseFour" class="accordion-collapse collapse" aria-labelledby="flush-headingFour"
                        data-bs-parent="#accordionFlushExample">
                        <div class="accordion-body">
                            <p>Undefined value primitive value is used when a variable has not been assigned a value.
                                undefined existence is a consequence of JavaScript's permissive nature that allows the
                                usage of: <br>

                                1. uninitialized variables <br>
                                2. non-existing object properties or methods <br>
                                3. out of bounds indexes to access array elements <br>
                                4. the invocation result of a function that returns nothing <br>

                                <b>Uninitialized variable: </b>
                                A declared variable but not yet assigned with a value (uninitialized) is by default
                                undefined.

                                Example: <br>

                                let myVariable; <br>
                                myVariable; // => undefined
                                <br>

                                myVariable is declared and not yet assigned with a value. Accessing the variable
                                evaluates to undefined. <br>

                                <b>Accessing a non-existing property: </b>
                                When accessing a non-existing object property, JavaScript returns undefined.

                                Let's demonstrate that in an example: <br>

                                let favoriteMovie = {
                                title: 'Blade Runner'
                                }; <br>
                                favoriteMovie.actors; // => undefined
                                <br>
                                favoriteMovie is an object with a single property title. Accessing a non-existing
                                property actors using a property accessor favoriteMovie.actors evaluates to undefined.
                                <br>

                                <b>Function parameters: </b>
                                The function parameters implicitly default to undefined.

                                Usually a function defined with a specific number of parameters should be invoked with
                                the same number of arguments. <br> <br>
                                function multiply(a, b) { <br>
                                a; // => 5 <br>
                                b; // => undefined <br>
                                return a * b; <br>
                                } <br>
                                multiply(5); // => NaN <br>
                                The invocation multiply(5) is performed with a single argument: as result a parameter is
                                5, but the b parameter is undefined.
                                <br>
                                <b>Function return value</b>
                                Implicitly, without return statement, a JavaScript function returns undefined.

                                A function that doesn't have return statement implicitly returns undefined: <br>

                                function square(x) { <br>
                                const res = x * x; <br>
                                } <br>
                                square(2); // => undefined <br>
                                square() function does not return any computation results. The function invocation
                                result is undefined. <br>
                                The same situation happens when return statement is present, but without an expression
                                nearby: <br>

                                function square(x) { <br>
                                const res = x * x; <br>
                                return; <br>
                                } <br>
                                square(2); // => undefined <br>
                                return statement is executed, but it doesn't return any expression. The invocation
                                result is also undefined. <br>
                                <b>void operator: </b>
                                void <expression> evaluates the expression and returns undefined no matter the result of
                                    the evaluation. <br>

                                    void 1; // => undefined <br>
                                    void (false); // => undefined <br>
                                    void {name: 'John Smith'}; // => undefined <br>
                                    void Math.min(1, 3); // => undefined <br>
                                    One use case of void operator is to suppress expression evaluation to undefined,
                                    relying on some side-effect of the evaluation. <br>
                                    <b>undefined in arrays: </b>
                                    You get undefined when accessing an array element with an out of bounds index. <br>

                                    const colors = ['blue', 'white', 'red']; <br>
                                    colors[5]; // => undefined <br>
                                    colors[-1]; // => undefined <br>
                                    colors array has 3 elements, thus valid indexes are 0, 1, and 2.

                                    Because there are no array elements at indexes 5 and -1, the accessors colors[5] and
                                    colors[-1] are undefined. <br> <br>

                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </section>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-u1OknCvxWvY5kfmNBILK2hRnQC3Pr17a+RTT6rIHI7NnikvbZlHgTPOOmMi466C8"
        crossorigin="anonymous"></script>
</body>

</html>